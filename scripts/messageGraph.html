<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8' />
    <title>Analysis of the massage graph</title>

    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            width: 100%
        }

        .svg-container {
            height: 90%;
            width: 100%;
        }
    </style>
</head>

<body>

    <h1>Analysis of the massage graph</h1>

    <div id="container" class="svg-container"></div>

    <script type="module">

        import * as d3 from "https://cdn.skypack.dev/d3@7";
        import { forceSimulation, forceLink, forceManyBody, forceCollide, forceCenter } from "https://cdn.skypack.dev/d3-force@3";

        // copied from assets/traceData/MorphDrawOn.json -> is easier for now than loading data from the file
        const data = {
            "GrafPort(BitBlt)>>fillColor:": {
                "DisplayScreen(1920x1023x32)": 1
            },
            "HMTracedMorph(Morph)>>wantsRoundedCorners": {
                "a HMTracedMorph(1601889)": 1
            },
            "Point>>-": {
                "0": 2
            },
            "SmallInteger(Number)>>adaptToPoint:andSend:": {
                "0@22": 2,
                "50@62": 2
            },
            "HMTracedMorph(Morph)>>valueOfProperty:ifAbsentPut:": {
                "a MorphExtension (1397234) [other:  (borderStyle -> a BorderStyle)]": 1,
                "a HMTracedMorph(1601889)": 1
            },
            "HMTracedMorph(Morph)>>fillStyle": {
                "a HMTracedMorph(1601889)": 1
            },
            "Rectangle class>>origin:corner:": {
                "nil corner: nil": 3
            },
            "IdentityDictionary>>scanFor:": {
                "borderStyle": 1,
                "cornerStyle": 1,
                "fillStyle": 1
            },
            "FormCanvas>>frameAndFillRectangle:fillColor:borderWidth:borderColor:": {
                "a GrafPort": 1,
                "a FormCanvas on: DisplayScreen(1920x1023x32)": 1,
                "nil corner: nil": 2,
                "Color transparent": 1
            },
            "Point>>+": {
                "0": 2
            },
            "GrafPort>>fillRect:offset:": {
                "a GrafPort": 1,
                "nil corner: nil": 4
            },
            "HMTracedMorph(Morph)>>valueOfProperty:ifAbsent:": {
                "a MorphExtension (1397234) [other:  (borderStyle -> a BorderStyle)]": 2
            },
            "FormCanvas(Canvas)>>fillRectangle:color:": {
                "Color": 1,
                "a FormCanvas on: DisplayScreen(1920x1023x32)": 1
            },
            "Rectangle>>insetBy:": {
                "0@22": 2,
                "50@62": 2,
                "Rectangle": 2
            },
            "FormCanvas>>setFillColor:": {
                "Form": 1,
                "a GrafPort": 3,
                "a FormCanvas on: DisplayScreen(1920x1023x32)": 1
            },
            "HMTracedMorph(Morph)>>drawOn:": {
                "a HMTracedMorph(1601889)": 3,
                "a FormCanvas on: DisplayScreen(1920x1023x32)": 1
            },
            "DisplayScreen(Form)>>bitPatternFor:": {
                "Color blue": 1,
                "DisplayScreen(1920x1023x32)": 1
            },
            "MorphExtension>>valueOfProperty:ifAbsent:": {
                "an IdentityDictionary(#borderStyle->a BorderStyle )": 2
            },
            "FormCanvas>>fillRectangle:fillStyle:": {
                "Color blue": 1,
                "a FormCanvas on: DisplayScreen(1920x1023x32)": 1
            },
            "[] in HMTracedMorph>>drawOn:": {
                "a HMTracedMorph(1601889)": 1
            },
            "MorphExtension>>valueOfProperty:ifAbsentPut:": {
                "a MorphExtension (1397234) [other:  (borderStyle -> a BorderStyle)]": 1,
                "an IdentityDictionary(#borderStyle->a BorderStyle )": 1
            },
            "HMTracedMorph(Morph)>>borderStyle": {
                "a HMTracedMorph(1601889)": 1
            },
            "GrafPort>>fillPattern:": {
                "a GrafPort": 1
            },
            "Color(Object)>>isKindOf:": {
                "Color": 1
            },
            "IdentityDictionary(Dictionary)>>at:ifAbsent:": {
                "an IdentityDictionary(#borderStyle->a BorderStyle )": 3,
                "a HMTracedMorph(1601889)": 2
            },
            "IdentityDictionary(Dictionary)>>at:ifAbsentPut:": {
                "an IdentityDictionary(#borderStyle->a BorderStyle )": 1
            },
            "Rectangle>>translateBy:": {
                "0@22": 1,
                "Rectangle": 1,
                "50@62": 1
            },
            "HMTracedMorph(Morph)>>cornerStyle": {
                "a HMTracedMorph(1601889)": 1
            },
            "FormCanvas(Canvas)>>frameAndFillRectangle:fillStyle:borderStyle:": {
                "0@22 corner: 50@62": 1,
                "a FormCanvas on: DisplayScreen(1920x1023x32)": 1,
                "a BorderStyle": 1
            },
            "[] in FullBlockClosure(BlockClosure)>>newProcess": {
                "a HMTracedMorph(1601889)": 1
            },
            "FormCanvas>>depth": {
                "DisplayScreen(1920x1023x32)": 1
            }
        };

        function randomColor() {
            const maxColorVal = 0xFFFFFF
            const randomColor = Math.random() * maxColorVal
            return "#" + Math.floor(randomColor).toString(16);
        }

        function uniqueRandomColor(id, dict) {
            var color = randomColor();
            while (Object.values(dict).includes(color)) {
                color = randomColor();
            }
            return color
        }
        function newNode(label) {
            return {
                label: label,
                index: null,
                x: 400,
                y: 400,
                vx: 0,
                vy: 0,
                radius: 20,
                category: label.match(/^.*>>/) ? label.match(/^.*>>/)[0] : 'default'
            }
        }

        function ticked() {
            d3.select('svg g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', function (d) {
                    return d.radius
                })
                .style('fill', function (d) {
                    return colors[d.category] ? colors[d.category] : colors.default
                })
                .style('stroke', "black")
                .attr('cx', function (d) {
                    return d.x
                })
                .attr("cy", function (d) {
                    return d.y
                })
                .on('click', function (d) {
                    console.log(d.target.__data__.label)
                })

            d3.select('svg g')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .text(function (d) {
                    return d.label
                })
                .attr('x', function (d) {
                    return d.x
                })
                .attr('y', function (d) {
                    return d.y
                })
        }

        var svg = d3.select(container)
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .call(d3.zoom().on("zoom", function (event) {
                svg.attr("transform", event.transform)
            }))
            .append("g")

        // create nodes
        const nodeMap = {};
        Object.keys(data).forEach((caller) => {
            nodeMap[caller] = newNode(caller)
            Object.keys(data[caller]).forEach(callee => {
                if (!nodeMap[callee]) {
                    nodeMap[callee] = newNode(callee);
                }
            });
        });
        Object.keys(nodeMap).forEach((nodeName, index) => {
            nodeMap[nodeName].index = index;
        });

        const nodes = [];
        Object.keys(nodeMap).forEach(nodeName => {
            nodes.push(nodeMap[nodeName])
        });

        // create color categories
        var colors = {
            default: 'white'
        }
        nodes.forEach(node => {
            if (!colors[node.category]) {
                colors[node.category] = uniqueRandomColor(node.category, colors)
            }
        })

        // create links
        const links = [];
        Object.keys(data).forEach(caller => {
            Object.keys(data[caller]).forEach(callee => {
                links.push({
                    source: nodeMap[caller].index,
                    target: nodeMap[callee].index,
                    strength: data[caller][callee] * 2
                });
            });
        });

        const simulation = forceSimulation(nodes)
            .force("link", forceLink(links))
            .force("charge", forceManyBody(-5))
            .force("collision", forceCollide().radius(function (d) {
                return d.radius;
            }))
            .on("tick", ticked);

        setTimeout(function () {
            simulation.stop();
        }, 5000);

    </script>
</body>

</html>